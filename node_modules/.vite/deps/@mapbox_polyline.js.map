{
  "version": 3,
  "sources": ["../../@mapbox/polyline/src/polyline.js"],
  "sourcesContent": ["'use strict';\r\n\r\n/**\r\n * Based off of [the offical Google document](https://developers.google.com/maps/documentation/utilities/polylinealgorithm)\r\n *\r\n * Some parts from [this implementation](http://facstaff.unca.edu/mcmcclur/GoogleMaps/EncodePolyline/PolylineEncoder.js)\r\n * by [Mark McClure](http://facstaff.unca.edu/mcmcclur/)\r\n *\r\n * @module polyline\r\n */\r\n\r\nvar polyline = {};\r\n\r\nfunction py2_round(value) {\r\n    // Google's polyline algorithm uses the same rounding strategy as Python 2, which is different from JS for negative values\r\n    return Math.floor(Math.abs(value) + 0.5) * (value >= 0 ? 1 : -1);\r\n}\r\n\r\nfunction encode(current, previous, factor) {\r\n    current = py2_round(current * factor);\r\n    previous = py2_round(previous * factor);\r\n    var coordinate = (current - previous) * 2;\r\n    if (coordinate < 0) {\r\n        coordinate = -coordinate - 1\r\n    }\r\n    var output = '';\r\n    while (coordinate >= 0x20) {\r\n        output += String.fromCharCode((0x20 | (coordinate & 0x1f)) + 63);\r\n        coordinate /= 32;\r\n    }\r\n    output += String.fromCharCode((coordinate | 0) + 63);\r\n    return output;\r\n}\r\n\r\n/**\r\n * Decodes to a [latitude, longitude] coordinates array.\r\n *\r\n * This is adapted from the implementation in Project-OSRM.\r\n *\r\n * @param {String} str\r\n * @param {Number} precision\r\n * @returns {Array}\r\n *\r\n * @see https://github.com/Project-OSRM/osrm-frontend/blob/master/WebContent/routing/OSRM.RoutingGeometry.js\r\n */\r\npolyline.decode = function(str, precision) {\r\n    var index = 0,\r\n        lat = 0,\r\n        lng = 0,\r\n        coordinates = [],\r\n        shift = 0,\r\n        result = 0,\r\n        byte = null,\r\n        latitude_change,\r\n        longitude_change,\r\n        factor = Math.pow(10, Number.isInteger(precision) ? precision : 5);\r\n\r\n    // Coordinates have variable length when encoded, so just keep\r\n    // track of whether we've hit the end of the string. In each\r\n    // loop iteration, a single coordinate is decoded.\r\n    while (index < str.length) {\r\n\r\n        // Reset shift, result, and byte\r\n        byte = null;\r\n        shift = 1;\r\n        result = 0;\r\n\r\n        do {\r\n            byte = str.charCodeAt(index++) - 63;\r\n            result += (byte & 0x1f) * shift;\r\n            shift *= 32;\r\n        } while (byte >= 0x20);\r\n\r\n        latitude_change = (result & 1) ? ((-result - 1) / 2) : (result / 2);\r\n\r\n        shift = 1;\r\n        result = 0;\r\n\r\n        do {\r\n            byte = str.charCodeAt(index++) - 63;\r\n            result += (byte & 0x1f) * shift;\r\n            shift *= 32;\r\n        } while (byte >= 0x20);\r\n\r\n        longitude_change = (result & 1) ? ((-result - 1) / 2) : (result / 2);\r\n\r\n        lat += latitude_change;\r\n        lng += longitude_change;\r\n\r\n        coordinates.push([lat / factor, lng / factor]);\r\n    }\r\n\r\n    return coordinates;\r\n};\r\n\r\n/**\r\n * Encodes the given [latitude, longitude] coordinates array.\r\n *\r\n * @param {Array.<Array.<Number>>} coordinates\r\n * @param {Number} precision\r\n * @returns {String}\r\n */\r\npolyline.encode = function(coordinates, precision) {\r\n    if (!coordinates.length) { return ''; }\r\n\r\n    var factor = Math.pow(10, Number.isInteger(precision) ? precision : 5),\r\n        output = encode(coordinates[0][0], 0, factor) + encode(coordinates[0][1], 0, factor);\r\n\r\n    for (var i = 1; i < coordinates.length; i++) {\r\n        var a = coordinates[i], b = coordinates[i - 1];\r\n        output += encode(a[0], b[0], factor);\r\n        output += encode(a[1], b[1], factor);\r\n    }\r\n\r\n    return output;\r\n};\r\n\r\nfunction flipped(coords) {\r\n    var flipped = [];\r\n    for (var i = 0; i < coords.length; i++) {\r\n        var coord = coords[i].slice();\r\n        flipped.push([coord[1], coord[0]]);\r\n    }\r\n    return flipped;\r\n}\r\n\r\n/**\r\n * Encodes a GeoJSON LineString feature/geometry.\r\n *\r\n * @param {Object} geojson\r\n * @param {Number} precision\r\n * @returns {String}\r\n */\r\npolyline.fromGeoJSON = function(geojson, precision) {\r\n    if (geojson && geojson.type === 'Feature') {\r\n        geojson = geojson.geometry;\r\n    }\r\n    if (!geojson || geojson.type !== 'LineString') {\r\n        throw new Error('Input must be a GeoJSON LineString');\r\n    }\r\n    return polyline.encode(flipped(geojson.coordinates), precision);\r\n};\r\n\r\n/**\r\n * Decodes to a GeoJSON LineString geometry.\r\n *\r\n * @param {String} str\r\n * @param {Number} precision\r\n * @returns {Object}\r\n */\r\npolyline.toGeoJSON = function(str, precision) {\r\n    var coords = polyline.decode(str, precision);\r\n    return {\r\n        type: 'LineString',\r\n        coordinates: flipped(coords)\r\n    };\r\n};\r\n\r\nif (typeof module === 'object' && module.exports) {\r\n    module.exports = polyline;\r\n}\r\n"],
  "mappings": "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",
  "names": ["flipped"]
}
